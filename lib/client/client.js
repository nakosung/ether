// Generated by CoffeeScript 1.6.2
(function() {
  var app;

  app = angular.module('client', ['ui', 'ui.bootstrap', 'ether', 'ui.directives']);

  app.config([
    '$routeProvider', function($routeProvider) {
      return $routeProvider.when('/', {
        templateUrl: 'template/home.html',
        controller: 'HomeCtrl'
      }).when('/shop', {
        templateUrl: 'template/shop.html',
        controller: 'ShopCtrl'
      }).when('/world', {
        templateUrl: 'template/world.html',
        controller: 'WorldCtrl'
      }).otherwise({
        redirectTo: '/'
      });
    }
  ]);

  app.controller('NavCtrl', function($scope, $location) {
    var NavMenu;

    NavMenu = (function() {
      function NavMenu(name, path) {
        this.name = name;
        this.path = path;
      }

      NavMenu.prototype.is_active = function() {
        return $location.path() === this.path;
      };

      return NavMenu;

    })();
    return $scope.navbar = [new NavMenu('Home', '/'), new NavMenu('Shop', '/shop'), new NavMenu('World', '/world')];
  });

  app.controller('MainCtrl', function($scope, collection, rpc, autologin, autocol, subscribe, $location) {
    autocol($scope, 'myroom test me sync:stat users_online stats mm rooms mm:stats');
    $scope.rpc = rpc;
    window.rpc = rpc;
    return window.col = collection.all;
  });

  app.controller('RoomCtrl', function($scope, collection, rpc, autologin, autocol, subscribe) {
    var sub;

    autocol($scope, 'myroom me');
    $scope.rpc = rpc;
    setInterval((function() {
      var _ref, _ref1, _ref2;

      if (((_ref = collection.all.myroom) != null ? _ref.owner : void 0) == null) {
        return (_ref1 = rpc.room) != null ? (_ref2 = _ref1["in"]) != null ? _ref2.claimOwner() : void 0 : void 0;
      }
    }), 1000);
    $scope.chat = [];
    sub = subscribe(/^room:/, function(channel, message) {
      if (message.joined != null) {
        $scope.chat.push("" + message.joined + " has joined");
      }
      if (message.left != null) {
        $scope.chat.push("" + message.left + " has left");
      }
      if (message.chat != null) {
        $scope.chat.push([message.sender, message.chat].join(':'));
      }
      return $scope.chat = _.last($scope.chat, 5);
    });
    return $scope.$on('$destroy', function() {
      return sub();
    });
  });

  app.controller('FriendsCtrl', function($scope, autocol, rpc) {
    autocol($scope, 'me');
    $scope.rpc = rpc;
    return $scope.autocompleteSuggesions = function(req, res) {
      return rpc.auth.list.users(req.term, function(err, result) {
        if (!err) {
          return res(result);
        } else {
          return res([]);
        }
      });
    };
  });

  app.controller('HomeCtrl', function($scope, autocol, rpc) {
    return $scope.rpc = rpc;
  });

  app.controller('ShopCtrl', function($scope, autocol, rpc) {
    autocol($scope, 'sku');
    $scope.rpc = rpc;
    return $scope.edit = function(sku) {
      console.log('editing', sku);
      return $scope.editing = {
        target: sku,
        actions: {
          Modify: function() {
            var doc;

            doc = {
              _id: sku._id,
              name: sku.name,
              price: sku.price
            };
            return rpc.shop.keeper.update(sku._id, doc, function(err) {
              if (!err) {
                return $scope.editing = void 0;
              }
            });
          },
          Cancel: function() {
            return $scope.editing = void 0;
          }
        }
      };
    };
  });

  app.controller('ShopKeeperCtrl', function($scope, rpc) {
    var context;

    $scope.sku = {};
    $scope.rpc = rpc;
    context = {};
    return $scope.editing = {
      target: context,
      actions: {
        Create: function() {
          console.log(context);
          return rpc.shop.keeper.add(context, function(err) {
            var k, v, _results;

            if (!err) {
              _results = [];
              for (k in context) {
                v = context[k];
                _results.push(delete context[k]);
              }
              return _results;
            }
          });
        }
      }
    };
  });

  app.controller('SKUEditorCtrl', function($scope, rpc) {
    return $scope.$watch('editing', function() {
      var _ref;

      return $scope.target = (_ref = $scope.editing) != null ? _ref.target : void 0;
    });
  });

  app.directive('playground', function() {
    return {
      restrict: 'E',
      transclude: true,
      link: function(scope, element, attrs) {
        var height, instance, refreshRate, width;

        width = parseInt(attrs.width) || 600;
        height = parseInt(attrs.height) || 600;
        refreshRate = attrs.refreshRate || 30;
        $(element).width(width).height(height);
        $(element).playground({
          height: height,
          width: width,
          refreshRate: refreshRate,
          keyTracker: true
        });
        instance = new scope[attrs.runner](scope, $.playground(), {
          width: width,
          height: height,
          refreshRate: refreshRate
        });
        return scope.$on('$destroy', function() {
          $.playground().pauseGame();
          $.playground().clearAll(true);
          return instance.destroy();
        });
      }
    };
  });

  app.factory('world', function(rpc, autocol, $rootScope) {
    var World;

    World = (function() {
      function World(scope, pg, opts) {
        var enter,
          _this = this;

        this.scope = scope;
        this.pg = pg;
        this.opts = opts;
        this.entities = {};
        this.handler = $rootScope.$on('rpc:update', function() {
          return enter();
        });
        enter = function() {
          var _ref;

          console.log('trying to enter');
          if (((_ref = rpc.world) != null ? _ref.enter : void 0) != null) {
            return rpc.world.enter(function(err) {
              console.log('enter returned', err);
              if (err) {
                return console.error(err);
              } else {
                if (typeof _this.handler === "function") {
                  _this.handler();
                }
                _this.handler = null;
                return _this.init();
              }
            });
          } else {
            return console.log('no rpc for now');
          }
        };
        enter();
        this.sprite_id = 0;
      }

      World.prototype.createEntity = function(opt) {
        var e, sprite_id;

        this.entities[opt.id] = e = opt;
        sprite_id = "sprite" + (this.sprite_id++);
        this.pg.addSprite(sprite_id, {
          posx: this.posx,
          posy: this.posy,
          animation: this.block,
          geometry: $.gQ.GEOMETRY_RECTANGLE
        });
        e.sprite = $("#" + sprite_id);
        console.log(this.entities);
        return this.updateEntity(opt);
      };

      World.prototype.updateEntity = function(opt) {
        var e;

        e = _.extend(this.entities[opt.id], opt);
        if ((opt.x != null) && (opt.y != null)) {
          e.sprite.xy(opt.x, opt.y);
        }
        return e;
      };

      World.prototype.deleteEntity = function(opt) {
        var e, _ref;

        e = this.entities[opt.id];
        if (e != null) {
          if ((_ref = e.sprite) != null) {
            _ref.remove();
          }
        }
        if (e === this.avatar) {
          this.avatar = void 0;
        }
        return delete this.entities[opt.id];
      };

      World.prototype.init = function() {
        var inv_map, k, v, _fn, _ref, _ref1,
          _this = this;

        console.log('World::INIT');
        this.initialized = true;
        this.block = new $.gQ.Animation({
          imageURL: 'img/24x24.gif'
        });
        this.pg.startGame();
        this.pg.registerCallback((function() {
          return _this.tick();
        }), this.opts.refreshRate);
        this.avatar = null;
        this.angular_spin = 0;
        this.speed = 3;
        this.keymap = {
          65: 'left',
          68: 'right',
          87: 'up',
          83: 'down'
        };
        this.key_handlers = {
          left: function() {
            return _this.avatar.x -= _this.speed;
          },
          right: function() {
            return _this.avatar.x += _this.speed;
          },
          up: function() {
            return _this.avatar.y -= _this.speed;
          },
          down: function() {
            return _this.avatar.y += _this.speed;
          }
        };
        inv_map = {};
        _ref = this.keymap;
        for (k in _ref) {
          v = _ref[k];
          inv_map[v] = k;
        }
        this.key_processors = [];
        _ref1 = this.key_handlers;
        _fn = function(k, v) {
          var fn, key_code;

          key_code = inv_map[k];
          fn = v;
          return _this.key_processors.push(function() {
            if ($.gQ.keyTracker[key_code]) {
              fn();
              return false;
            } else {
              return true;
            }
          });
        };
        for (k in _ref1) {
          v = _ref1[k];
          _fn(k, v);
        }
        this.packet_handler = $rootScope.$on('sockjs.json', function(e, json) {
          if (json.world == null) {
            return;
          }
          return _this.handlePacket(json.world);
        });
        return rpc.world.hello();
      };

      World.prototype.handlePacket = function(json) {
        if (json.spawn != null) {
          this.avatar = this.createEntity(json.spawn);
        }
        if (json.add != null) {
          this.createEntity(json.add);
        }
        if (json.update != null) {
          this.updateEntity(json.update);
        }
        if (json.remove != null) {
          return this.deleteEntity(json.remove);
        }
      };

      World.prototype.tick = function() {
        var moved, _ref, _ref1;

        if (this.avatar != null) {
          moved = !_.every(this.key_processors.map(function(x) {
            return x();
          }));
          if (moved) {
            rpc.world.update.unreliable(this.avatar.x, this.avatar.y);
          }
          this.avatar.sprite.xy(this.avatar.x, this.avatar.y);
        }
        if (this.angular_spin-- < 0) {
          this.angular_spin = this.opts.refreshRate / 4;
          this.scope.stats = {
            x: (_ref = this.avatar) != null ? _ref.x : void 0,
            y: (_ref1 = this.avatar) != null ? _ref1.y : void 0
          };
          this.scope.$apply();
        }
        return false;
      };

      World.prototype.destroy = function() {
        if (this.initialized) {
          this.packet_handler();
          this.packet_handler = null;
          this.initialized = false;
          rpc.world.leave();
        }
        if (typeof this.handler === "function") {
          this.handler();
        }
        this.handler = null;
        return console.log('destroyed', this);
      };

      return World;

    })();
    return World;
  });

  app.controller('WorldCtrl', function($scope, rpc, world) {
    return $scope.runner = world;
  });

}).call(this);
